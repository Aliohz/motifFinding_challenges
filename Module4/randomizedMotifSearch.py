### Code Challenge: Implement RandomizedMotifSearch.

### Input: Integers k and t, followed by a space-separated collection of strings Dna.
### Output: A collection BestMotifs resulting from running RandomizedMotifSearch(Dna, k, t) 1,000 times. Remember to use pseudocounts!

import numpy as np
import random

dna = '''
TGTTTGGTCTAGTAGCATGGTGGCAAGAAAAATTTGGGTGACCGTTTGTTTGCACGGGTTTACGCAGTTTATGGACAAGTCTACAACTGCAAAAAGTGACTAATTTCGGCGATTAAGAAAAAATCAAGGGATGCGTCGGTTTCTCCAGCACTCGATACGTGGCTCTAAGCATTTGAATGCGGTAGTGAATGGTCCCGGCTGCTGCTTCCGACACGATAGCATGGCCGATTGGATGTGCCAGGCGCCTGCTGTTGGGGAAAACTCGCCCTTTAACCCTGAGTTCGTTCCTAAATCTCCTGCTGTTTGGTCTAGTAG CATGGTGGCAAGAAAAATTTGGGTGACCGTTTGTTTGCACGGGTTTACGCAGTTTATGGACAAGTCTACAACTGCACAAGCAGTCGGACGGAAAAGTGACTAATTTCGGCGATTAAGAAAAAATCAAGGGATGCGTCGGTTTCTCCAGCACTCGATACGTGGCTCTAAGCATTTGAATGCGGTAGTGAATGGTCCCGGCTGCTGCTTCCGACACGATAGCATGGCCGATTGGATGTGCCAGGCGCCTGCTGTTGGGGAAAACTCGCCCTTTAACCCTGAGTTCGTTCCTAAATCTCCTGCTGTTTGGTCTAGTAG GCTTCCCCCTCTTTGACATGCAAATTGTCTCCCGGATTTGCGGGTGTTTTGCCGACACGTTGCCCTTGCATCTGGACTTGCGCGTCAATAATAGCATCCCTGGGAAGGTTACCGAACAATATGAGGGACCCTCACGATAGCTGTTGGCCCCCTAGTACCTACATTCGGGTGAGTTACTGGCCTTAAATTGTAATGCTACTGTGTGGCGTTGCGTTCGGAGCTGATATTCATCTTCCGTCATGGAACTTTCAACACTGCCGAGTGAGCCTAGTAAGAACTTGCCACAGATCATGAGGTACCACAATGATGCTCTCT GTGTTCACTGTCCCCATCGAGGCTATGAATGGCCAAGGGCGGTGAACAACCCACAAGCTATGCGTCATCCGCGGCGCCTCTGGTAGGGTCGTCTCTACCCATAGTGGACAATCGTGCGCGTGTAAGTCACAAATTTGGGGACGGTAATTTTATAGCCCCGCATGGATCTCCCCGTGGTGTAGCCATGAGGCGTAGAGTTTAGTGTTTTACTAGATCATGCAATCTCCGTGGAGTTTGTTCGTCGGAGCATTTATGCGATGAACTATGCGGCCCCTTGCTTCCACCCATGCAGCATTTTTCGCGGCACCTCGCCAA TCTGTGGTGATGAATCGTAATACGTTTAAGGGTCGTAATATCTACCTTAAGATAAAGGGTAAGCAACAATCCTACCACAGGCAGCCTATCCAGCATAAGATAGAAGTGCGATCGATGAGCACAATGCGAAACCTCCATACTTGGCTCCGGAGGTGTTTTGGATGCTGTCTTCTGCCGGACAGTGCACAACCCCTGAGGAGCGACAAATTGTGCTACGGGACACGACGGACGCAAACGACATCAAGATAGGAAATTGGCGGACTTGAGGGGTTACCTTTGCGGGGAAGTCGTGGGATGGCTCTCTAAATTGTCTTA GTATTACCAATATAGAGGTTGTGCGTGATTTTGCGTCACTGGAGAAAATTCACGTGGCCTTCGTAACTCATTCCACTATATAGGCCCTTCCTCGAGAGGGGGAAGAAGCGCTTTACGTTGCCTGGTCTGTAGTGCCTATTCTCTGGCTATTGCCGTTTGGAGCTTCCAGACCCGTGCCAGACTTCGACGATGCCCGAGGCGTGTAAGACAACAACCAAGACCTTTTCTGAGTTTTACGTGCCTCTGGACGACTCGCTCTACCTGGTTGTGGACAAATGTACGGACGGCAGAGACACGCAAATGTGCTGCCCTGAG CATGTTGTTTCATTGAAGCCACTGCGGGGGCTCTAAGGCTTGATGGGCGATTGTTTGAGATCGTAGTCGGGGTAGACCCGTTTTCAGAGTCCGCACGATGAAATTGTCGGACTTGATCTGTGTCTTAACTCTTGACAAAAGTCGGCCATGGCCCGTGTACACACGCGTATTGCAGAAACCGAGATCTTCAATTGGTAGAATGTGACCGCTAGGCCCCTTGAAGCACCATATTCTACCTCGGGTCGAGAGTGCGCATCTTAGCGGTGTACTATCGTCCTAATTGCCATCTCCATAGTAATCAATGGGCCGAAGGAC ATACCAGCTGGCCAACTGGAAAATCATATCATGGATGCGGACTATTCACTTTGTGTTAGCTCCTATAAATCACAGGGTCGTTCGGATTACAGAACAGGAGGCCCGACGATTGGGAGCTGATGTTCCCGTGTTAAAATACTCTGAGATAGCTGAACAGTTGGTCATTCTGTCGGACGGCTTCCTTCAGGGTGTTCCCGGTCCTTTTCAGCTTTGCGTATGGTATACATCATGGCGACTCCTCAGGTTTCAGACTGCCTGATGTGGGCCATCTACTCATCTATGTACATGACTGACTAATTGCCGGCCGTGTGCGGT GGGAGCAGTAACCGACTAGATGGGTTGAGGCACGTAGGGTGTTAAGTTCAAAGCGCGGATTAATACCCATCTTCTTACCTTGTGCGCTTAGACTACATTGGGGCGTTGTTATTGGGGAACGTACACCCCCGCGTATAGGCCCAAAATGCCTGCCGCCCGACGTTCAATTATCAACTCATAAAACGACATAAGGTCTCTCCTAGGCCATCTGTAATTGAGGAATCGTCCGCGTAACACATTCAAAGCGTATGCAAATAATTGTCGGACGCGCGGCGAAAAGCCTTACATCAGAGCCCTGATCCTATTTTTGGCCCG ACACACATGTCATAAACCGAAGGGGAAACCGTTGGCAGCATACTTGCCTAGCACCTCGACGACAAACACAACCCCGCCGAACGTACTACCCCAATGAGTCGGACGGCACTCCTGGATGCAAATAGCATGGATCCTCATATCCTGTGAGCGGTGATAGCACGGCCTGATACCCACTTTTAGTAAAAAAGGGACCCCAGAGCTCTGCGTGCACCAACGCGGCCGATAGATTACCCCATGTGTTCACACCTATGTGAGATGCTTACGTACGCTGCGGCCACGAATCGTTTCTGGTGCCATCCGAAGGCCACATAGTAG GAGTCTTCAAACAAGCTTCTCGGTTAAGCTTCTACCGGCACTGGTGCAACGATTACCTAGGCCATCTATTGGCGCTGTAGCTAGGGTGCGGGCGCCAGCAAACTGTACCGGCTCAGCCAACCGGTAGTAGAAGGCAAGAGTGCATTGCGGCACCATTTTGGGGGATGTATGCAATTCAGGCACGAGGGGAGCCAATTTACCACGGTCACCTTTAACAGGGCCAGTGTCGTACAATGTGATGTCGTAATCAACCAGACTGATATCCGTGCACGCACAATCAGCGCAAGCCCCCAAAGGTTCGGACGGGGCCCCACG GCTTGACCACGGGTTGCACGGTCACCCCTAGTTCCTCTTTAATACTGAGTTAAGCCAAGCTAACTGCTGATGACGTGACACAGGGGCAGCATTGTCGGACGGGGGAGAATAATTTTGCGAGCTCTTTTGCTCCCCTAAGCATTATGCGTAGATAGGACTATCACCCGGCTGGTTAAAAGGGATCCGATGCACAAAATAACGCATCCTAGGAATGATCTGCTCATAAGGCGGTTCAGGACGGGGGTTCACCGTATACTCTGCGGTCCAACCATCTAATACAGGCTGATCACCATAGGGACAGGTATACGCAATTGT TTTCCCCTTTCCTTGGTTGGATCCGCTGTTGATTCTAAAGGCAGTATTCTCGGCGACGTTAGACCTACCCTTCACATGGCCATTACTTTCCTTCTTGTCGGACGGTTGCTCCATATAGGTACCCACGCCCGATCGGATCTAGCCACTGAGAGCGGAACCTGCCCGAGTTATTCCCCGTAACCAGGCGAGATTATTGACCGGTAGCTAGACTACAGACCCACGTAAATTCCTTATGTGGCTCCCTTCCTACTCACACGAGGATGGCGTCTGTCCAGCTGAGGATAACACTGAGGCTACCATCTGCAGCTATTTACC ACATTCTGTGGAGTTTACAGCACCCTGCATACAACGGCCTACATCTGCTCTAAGTGCCACGGTGGAGGTTACGCTCGTTCTGTGAGTGGTAACCCCGTTTTCGGGACCAATTTACCCAAACGTCGGGTCAAAAAAAAGAGCATCAGATCATTGCGCAAGCGACGACAACTCCACGGAGGGAATAGACGAGAGTCCCGTCAATTCGGAGATGAGTTACCTCCATCCGTCGCAAGTGCCGGTTCCGTACTAGGCGTCCGCTTTATAGACAACCACGTCACACCTTGATTCTAATTCAAATTGCATGACGGTGCGGAT TGTTTTCCGGTTCTACGAGAGTGCGTCCTCGAAAAATACTAATTTCGTTAAACGTCGCACCCACTAGGGGGGACCCCCGCTGACAGTTTCTAGGCCTGTTAGACTCCACTTCCCCTCTACCGTTGCTTCCATAAATTCTAAAGATCCGTGGTCGGTTCGCCAAGTGAGTATCCGTATGCAGATCAGTTAGGAACATAACCAAGGGGCTGGATTAGAAGTGAATGAGTAACCTCGACAATTGGTCGTCCGTCAAAAGCAGCTTGATGGGCACATATATAAGGGAATAATAGTTAAGGCAAACATTCGGACGGTTTA TGAGGAGCGATTAAATGTAGATATTAACAGGGTCACGGGTATTATATCACACTCCGGGTCAGTACGACACTTGTTTCTGCAATTGCTAGGTTACGATGCGGGGTTTACACAAATCACCCGCAAGCATGCCCTTGGCGGGCCACTGCACTAAGAGCCGCGACTGAATGCAGGTGTGCATGTTTAGTCTAGACACTAGTCGATTTACTAATACGCGAATGCGAGAGCTGGAATTTATGATCCGCCCGCAGGAGATTCCACCCGTAATACCTACATTTGTTCGTGGATCAAATTGTCGGTTCGTCACAGCAGAGTAAT CGGTAGGGTTTGGTATGAACTTCTTAAAAGAAAATTGACTAACACGTGTTCGATTAACGGCCTGATAACCATACAGCGCAGTTACAGCTATCTCGTCTGAACTCGAGAATTAGCGTAACAGCCACACACCATCAAATTGTCGAGGGGTGAGAAGGCTCCTTGACTGTAAACATCCCACATCGAGAGTAGTGTTGATAGCTAAGGAGGCCTGATTGATGGTAACAGCGGCCACAAGTAATCGCAACTCATAGTCGAGTTGTAGCGGAAGCTGCAAAGCCCAGTTCTCCTACCAGACTACGTAGAACGAACTAACGA TAGACGCTTCAGGTCACCCTTATAAACAAAGGCGGTATTAACCTCATATGACTGGTGACCAGTGGATTTCTCCTCAACATTTGAGTGGGCTGAAGGATCGGAGTTTCTGGGTCAACTACCAGTGTTTGCCTCTAGTTTACTTACGTCTCGACCCATAAGGAACCGTGACCCAAAATGTCACTGCAAGGCTCCATTAATAACCGGACCTATCCTTACACAAACATTATCTGTTTTCTCAGCTTAGTATGGCTAATGAAGCACGTCGTGAGAAGGTTAGCTCATATGGCGACCAAATTTAGGGACGGCGGACACGCG TCGCGGCCAGAGAGCGGATCGGTCATCGTATTAAACCCTTCGACGAACCGCGCGGCTCAGACTGTGGTTGGTATGAATCTCTGTCACCGTTCGACCATAAACCGTTGCATTCGAGCGCTCAGCATTCGTTCGGCGCCTCAAGCAGAACTTCACTTGGATCTAAGATCGTAAAGCAAAGAACCTTGTTCTGTAAGTCTTGAATCACCCTCAGTCGCAAGGAAGAAGAGGGTATCCCGGGACACACTACGGTGCTTCACACAAGAGCCAAATTGTCGGAACACGGTGTCATTTGTGAGAGAGACGAGGTGATATCCC ACATCCCACGGATGGACGTGAACCCGGTTTCAAGGGTATGCTGCGCCAAACCCACAGGCTTGGACAGGACATCCACCAAATATGCGGACGGCGAAAATCTTTATCTTACTTAACGTTGGAAGGTGGACGTGATTTCCTACATGCGGGTCAGTAGGCAAAATTAAGGGCAGGTTCCACGATCGTGGGCCTGCAAAGCCGCTGTGCGACCTCCCATAGACCTGAAAGGGGTCATCGCCATCAAGGCACATGCCGGCCCGAGGAAAGCGTAGAATAAGACCCTAAACTTTACACCTCGCTGTGAAGCAAGTTTATGCT
'''
dna = dna.split()
k = 15
t = 20


# From greedyMotifSearch_pseudocounts
def buildProfilePseudocounts(motif_matrix, k):
    profile_rows = {"A": 0, "C": 1, "G": 2, "T": 3}
    t = len(motif_matrix)
    profile = np.full((4, k), 1 / (t + 4))
    
    for column in range(k):
        for motif_row in range(t):
            nucleotide = motif_matrix[motif_row][column]
            profile_row = profile_rows[nucleotide]

            profile[profile_row][column] += 1 / (t + 4)

    return profile


def score_motif_matrix(motif_matrix):
    columns = len(motif_matrix[0])
    rows = len(motif_matrix)

    score = 0

    for column in range(columns):
        frequency = ""
        for row in range(rows):
            a = motif_matrix[row][column]
            frequency += a
        
        max_count = max(frequency.count(nucleotide) for nucleotide in 'ACGT')
        score += rows - max_count

    return score


# From profileMostProbableKmer.
def kmerProbability(kmer, profile):
    profile_rows = {"A": 0, "C": 1, "G": 2, "T": 3}
    kmer_probability = 1

    for i in range(len(kmer)):
        row = profile_rows[kmer[i]]
        column = i
        nucleotide_probability = profile[row][column]
        kmer_probability *= nucleotide_probability

    return kmer_probability


def profile_most_probable_kmer(single_string_dna, k, profile):
    n = len(single_string_dna) + 1
    highestProbability = -1

    for i in range(n - k):
        kmer = single_string_dna[i:i+k]

        kmer_probability = kmerProbability(kmer, profile)

        if kmer_probability > highestProbability:
            highestProbability = kmer_probability
            most_probable_kmer = kmer
    
    return most_probable_kmer


# New functions
def getRandomMotifs(dna, k, t):
    n = len(dna[0])
    randomMotifs = []

    for i in range(t):
        start_pos = random.randint(0, n - k)
        motif = dna[i][start_pos:start_pos + k]
        randomMotifs.append(motif)
    
    return randomMotifs


def getImprovedMotifs(profile, dna):
    k = len(profile[0])
    improvedMotifs = []

    for dna_string in dna:
        better_motif = profile_most_probable_kmer(dna_string, k, profile)
        improvedMotifs.append(better_motif)
    
    return improvedMotifs


def randomizedMotifSearch(dna, k, t):
    motifs = getRandomMotifs(dna, k, t)
    bestMotifs = motifs

    while True:
        profile = buildProfilePseudocounts(motifs, k)
        motifs = getImprovedMotifs(profile, dna)

        if score_motif_matrix(motifs) < score_motif_matrix(bestMotifs):
            bestMotifs = motifs
        else:
            return bestMotifs


score = float('inf')
for i in range(4000):
    print(f"\nThis is loop {i+1}.")
    motifs = randomizedMotifSearch(dna, k, t)
    current_score = score_motif_matrix(motifs)

    if current_score < score:
        score = current_score
        bestMotifs = motifs

for best_motif in bestMotifs:
    print(best_motif, end= " ")
