### In order to improve this unfair scoring, bioinformaticians often substitute zeroes with small numbers called pseudocounts. The simplest approach to introducing pseudocounts, 
### called Laplaceâ€™s Rule of Succession, is similar to the principle that Laplace used to calculate the probability that the sun will not rise tomorrow. In the case of motifs, 
### pseudocounts often amount to adding 1 (or some other small number) to each element of Count(Motifs).

### Code Challenge: Implement GreedyMotifSearch with pseudocounts.

### Input: Integers k and t, followed by a space-separated collection of strings Dna.
### Output: A collection of strings BestMotifs resulting from applying GreedyMotifSearch(Dna, k, t) with pseudocounts. If at any step you find more than one Profile-most probable 
### k-mer in a given string, use the one occurring first.

import numpy as np

dna = '''
AGCGTGCATGTTTGAGAAGGTCGTTAGATAAAGAGGTCCAAGCGGTACACGTTAGGGCGAGGAGCAAATGCGAACCTATGTAACTGCCACTAGACCGGTGCGTTCAATAGTTTATCTTCAGGAGTCGGCCGTGTGCTAGTCCTACTCGTTCGATAG GCCGGTAGATACGTGCTTTCCGCATGCACGGCTACACTCTCTCGAAAAGCAGCGGCGTGCTAGATTCAGTCGTCCCACAGTTTTCCGCAGGTAACAGGGGGTGCACGCTACCGCGGTATCCGAGATTACCAATTGGATTGAAAAATGCCGGTCCTC GGAATAGTTTTATTACAGGATGAGTATTGACATTTGGCTGCACATGAGTCCTGTCGGAGCCTCAGATGAAGATAGGAAGCACTAGTGCGCGCATCTAGTGCGCGGGTACCGAGGTTTATTAAAGAAGCACTTAATCGCATAAGCTAGATGCAGCAG TCAACCTACTGGGGGAATTCCCTTAATTAAGCATTAGCTAGTTACTAAGACAGCTTGCGTTAGTCTTACGTATAGATACAGTAGGCGAGCTTCGATACGAAGGGGAATCGATCATAGTAAAATGTGCTAGCATATCTTGGTAGCAGGGATCTAGGC ATGGTCTATGAACGATAGGGTCAAAAGCACTGACGGCCAGCTTCACTCATCGATTCAGTCATAATTGTTTCGCCCTAGTACCCCCAACCCCGCAAAATCGAGTACAGTTAGATAGAGTAGTGGTCTGAGGATTTGTAACATTCTATAATATCCAAC CATAACCCGCTATAGATGCAGTGGAACGCTGAGCAGCCGGAATTGTTGTCGGACTTTCACTGGACCAGGTAACGTGATACCTAACGTCCGCACCGACTGTATCCGCCAGGAATGGGCGAATGCATCACCGTCCCCGGTTTGACATAATTAAGTACT ATGACAGATCGAGTTTTATGCTAAACATAATTGTTTGGATGGGAGAGTTAGATTGAGCAGAAAGAGGTCGTGTCCCAGTCTGGGTCCCCCCGAACTGCCGCCTTGGCGCTCACTTAGCAGAGTTGGATAGTAGTTAAATGGCGGTCAAATACTGAA TAACTTCGGTATTACCTTTCTTAGTCCTTCCTTTATCTGCGATCTATATACGAGGATTTTCATTACAAGACCCCTTCCTCAGTATAGATCGAGGAGGGGGTAACAATAAATTGCACCAGCTACACACACGCACTATTCAGATGGTCTAAGCCTCCC TAGTGATACTTTATAGCACTAAAGGGAGTTGCGTATTTACACTGAAAAGAGTCACTCCTGGCGTAACTCCTTCAGTCCCTTTTCGGAGGGTTGCTCACTCAGTGTCCCGACGTACTGGCCTAGATAAAGGAGGTAAGAGTTTCTGATCTCTTCATT CCGGGCAGGAAAAAGGCGGCGTCACTACTCCCTGCTATCCGGGACATATGGCGATATACCGTTCTTATCCTTAGATAGAGACTCCTACCCAGACACTAGATCTAGTAGAACCTACTCGGGGCCTAACGCGGTACGAGTCCATCCGTACTCAGGTTG TGGTTCGGCTGCAGGGATCCGGCTTAGATCGAGTGGGTCGTTGACATTGGAACACACGGTGCGAGAGTCATCTGACTCGCCTGAACTAAGACTTGTTGCGGTGCTTACCGTACGGTGAGTTCACCACGGCCGACCACTAGCAAGTTCCCGTTAAAC GATCGAGGAAGACCAAATCCTACGGCGGGTTGGGTCCTTTGAGTCGTTTAGATTCAGTTGAACTCGCATTGTGGGATCGTTTGGCCTTCGGTCTCAAAACGTAGGCCTTACGGGCACTTCTTGCCCGGCGACCCCCGCCGGTAACATGCTCCAGCT GCCCAGCAAGGCAGTGAAATTCGCCCTTTCGTTCGCGTGCTAGTTGGACAAGGCTGTCTCGTCGGGACAGATAAGGTGGATCGTCTCGCCATCCTATAGATGCAGCCGGTGCGAGAACTTCGGACTGCACACTGATCTCAGTAGCCGCACATGGAT ATGTGTCACCGAGTGTTTATACCGCTAGGTTGTCACCAAACTAGCGAGTCTGCGACAATGTAGATAGAGTAGGAGAACACTCTTCGAAAATAATTCTCGTATGGCCTCTAGTCCCCCGCTTGCAAGGTAAGGGAGGCCCTTCATCACCGCAAACAT ACCGCCTTCCTACACTCAGAGATAAGATTGATAGAGGCATCCAGTGCTCAAATTTGGAGTTATGGGTGTTCGTAGATCTAGCTGTCATTGTTCCCAGATCCAATGCCGGCTTTTACCGACCACCGACGACGTTTACCGCTGACACTGCAAAACATA AGATTCCACAACAACCCTATAACTGCCCCATAGAATTCAATCTTTGGCTAGATCCAGAAGGGAAAGACATACCCGTGGCGCACGCATGCCCGACTTAATTCCAACATATCACGATGTCAACGATGTCATCTAGTCGCTGTACTAATTTCCACCATC TTCAATTTATGCATAGTTGGCGCGCTCTTTACCCGTACCCAACATAACTACTAGCTTCGGCGTTTCTTACTCCTTGCCATGCTTAGCTCATAGGGCAGATAACATTCCAAGTGAAACTGGCACGTGGGTTAGTACAAGCTGTCCTAGATATAGCGG GCGTCCTTCCGTAACCTGCCCTGACACATTTTCTGATACACATTAAGTTAGCGGTTCAGGGGTCCAGGGCACCAAGTAGGGAGGGTTGCGACACGACATTAGAGGCTTTAGATAAAGTAGCTCGAAGCTCCGTCGGGTGGTTTCTTTCGCCCTGAG ACAAAGGGGGTTGAGGTCGATCTGTCAATTGGTCTTAATCGCTTGAACTTCTTGTCAAAATGAGAGAAATTCCCAGGTCTGTAGTCTTTACGTCGCTAGATTCAGGGGCGTTTCCCTGACGAGATTGAGTCCACGAGCGTAGTATAAGCCTTCCTT GGCGCTGACTGTGGTAATAGAAACTTAAGACTATCCTAGATCTAGTAGACACGCTCACGGGACACGTATTTGCGTATCCTTTGAACTCAGATTTAGTCCCCGAGCCAGCGGTTTGCTCTAGAAGGCAGAGCTTACTGATTTACAGCTGGCCTTCCA ATTACCCCCGGCCAGGTCCGGTATATCCCATGCGCGTTATGGCCATAGTAGATTGAGACGTCATGCTGATTGTGAACGGACGTAGCGAAGGGGGTCATGGGCAATATTCAAAAGCTAGATGGTACGTCGCGGTGTCCATATCTAGCAATACACGCA ACGAACCAATGTTGTCTACTGGTTCAACGTGACAGTAGTATACTCAAAAGCTATGCCCGTACCGATCTCTGCAGTATGGCGCTCGGTGCGGTCTCTGACGGTGTAGAAATTTCAGGAACATAGATGTAGCAGCGTTACGCGTGCGTTGCTGCGATT CCGATGATGAGAGTTGTTTGTACATAGATTTAGGCGCAGACGGTTTTACGCCTTCCCAAGGCGAGAACGTTGGGCAAGAAGCTTATATCAATAAGTTCGTTGGTGGGTCATCTAATCCACCCCGGACCCGAGCGCGACCGCCCCGCAATTCGTGCA TAGATACAGCAGGCTATTCGTATAAGCTCTGAAGGGGGAATGGATACGCATTTAGTACTTACTGGGCATGACAGTCATCGTACTGTAGCTTGTGATCCCGGTAATGCGACGAGAGCTAGGACATGAGGTCTGAATCGCGCTAAGTAAGGGATATCA AGCCCTGACGTGTCATGCGGTTGCTGAGAGCCCCTCAATACTCATAGTGCTGATAGTCAGAGACAACCATGCAAGGTGTCGTCAGGAGACAACAATAATTTGTAATTCTAGATGAAGAGGGAGCGGAGCCACTGTATGTCTTGTTTTTAATGCATA
'''
dna = dna.split()
k = 12
t = 25


def buildProfile(motif_matrix, k):
    profile_rows = {"A": 0, "C": 1, "G": 2, "T": 3}
    t = len(motif_matrix)
    profile = np.full((4, k), 1 / (t + 4))
    
    for column in range(k):
        for motif_row in range(t):
            nucleotide = motif_matrix[motif_row][column]
            profile_row = profile_rows[nucleotide]

            profile[profile_row][column] += 1 / (t + 4)

    return profile


def score_motif_matrix(motif_matrix):
    columns = len(motif_matrix[0])
    rows = len(motif_matrix)

    score = 0

    for column in range(columns):
        frequency = ""
        for row in range(rows):
            a = motif_matrix[row][column]
            frequency += a
        
        max_count = max(frequency.count(nucleotide) for nucleotide in 'ACGT')
        score += rows - max_count

    return score


# Imported form profileMostProbableKmer.py
def kmerProbability(kmer, profile):
    profile_rows = {"A": 0, "C": 1, "G": 2, "T": 3}
    kmer_probability = 1

    for i in range(len(kmer)):
        row = profile_rows[kmer[i]]
        column = i
        nucleotide_probability = profile[row][column]
        kmer_probability *= nucleotide_probability
        
        if kmer_probability == 0:
            break

    return kmer_probability


# Imported form profileMostProbableKmer.py
def profile_most_probable_kmer(dna, k, profile):
    n = len(dna) + 1
    highestProbability = -1

    for i in range(n - k):
        kmer = dna[i:i+k]

        kmer_probability = kmerProbability(kmer, profile)

        if kmer_probability > highestProbability:
            highestProbability = kmer_probability
            most_probable_kmer = kmer
    
    return most_probable_kmer


def greedy_motif_search(dna, k , t):
    n = len(dna[0]) + 1
    min_score = float('inf')

    best_motif_matrix = []

    for i in range(n - k):
        motif1 = dna[0][i:i+k]

        #for j in range(n - k):
        #    motif2 = dna[1][j:j+k]

        motif_matrix = [motif1]
        profile = buildProfile(motif_matrix, k)

        for dna_string in range(1, t):
            next_motif = profile_most_probable_kmer(dna[dna_string], k, profile)

            motif_matrix.append(next_motif)
            profile = buildProfile(motif_matrix, k)
                    
        current_profile_score = score_motif_matrix(motif_matrix)

        if current_profile_score < min_score:
            
            min_score = current_profile_score
            best_motif_matrix = motif_matrix

    return best_motif_matrix


bestMotifs = greedy_motif_search(dna, k, t)

for motif in bestMotifs:
    print(motif, end= " ")
